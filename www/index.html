<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Active Peers</title>
    <style>
      body {
        font-family: system-ui, Segoe UI, Roboto, Arial;
        max-width: 900px;
        margin: 24px auto;
        padding: 0 16px;
      }
      h1 {
        margin-bottom: 8px;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin: 12px 0;
      }
      th,
      td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
      }
      th {
        background: #f5f5f5;
      }
      .row {
        display: flex;
        gap: 8px;
        align-items: center;
        margin: 8px 0;
      }
      input,
      button {
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
      }
      button {
        cursor: pointer;
      }
      .status {
        margin-top: 8px;
        font-size: 0.95rem;
      }
      pre {
        background: #f6f8fa;
        padding: 8px;
        border-radius: 6px;
        overflow: auto;
      }
    </style>
  </head>
  <body>
    <h1>Active Peers</h1>

    <div class="row">
      <button id="refreshBtn">Refresh list</button>
      <button id="autoRefreshBtn">Start auto-refresh</button>
      <span id="lastUpdated" style="margin-left: 12px; color: #666"></span>
    </div>

    <table id="peersTable" aria-live="polite">
      <thead>
        <tr>
          <th>Username</th>
          <th>IP</th>
          <th>Port</th>
          <th>Action</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td colspan="4" style="text-align: center; color: #666">
            No peers yet
          </td>
        </tr>
      </tbody>
    </table>

    <!-- Connected Peers Section -->
    <h2>Connected Peers</h2>
    <div class="row">
      <button id="refreshConnectedBtn">Refresh connected</button>
    </div>
    <table id="connectedPeersTable" aria-live="polite">
      <thead>
        <tr>
          <th>IP</th>
          <th>Port</th>
          <th>Action</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td colspan="3" style="text-align: center; color: #666">
            No connected peers yet
          </td>
        </tr>
      </tbody>
    </table>

    <!-- Send Message Section -->
    <h2>Send Message to Peer</h2>
    <div class="row">
      <input id="msgPeerIp" placeholder="peer ip (e.g. 127.0.0.1)" />
      <input
        id="msgPeerPort"
        placeholder="peer port (e.g. 9001)"
        style="width: 140px"
      />
      <input id="msgContent" placeholder="message" style="width: 200px" />
      <button id="sendMsgBtn">Send Message</button>
    </div>
    <div class="status" id="sendMsgStatus"></div>

    <!-- Broadcast Message Section -->
    <h2>Broadcast Message to All Connected Peers</h2>
    <div class="row">
      <input
        id="broadcastContent"
        placeholder="broadcast message"
        style="width: 220px"
      />
      <button id="broadcastMsgBtn">Broadcast</button>
    </div>
    <div class="status" id="broadcastMsgStatus"></div>

    <h2>Register this peer</h2>
    <p>Provide a username for your peer.</p>
    <div class="row">
      <input id="username" placeholder="username" />
      <button id="registerBtn">Register</button>
    </div>
    <div class="status" id="registerStatus"></div>

    <h2>Connect to a peer</h2>
    <p>Enter target IP/port and attempt a WebSocket connection (ws://).</p>
    <div class="row">
      <input id="targetIp" placeholder="target ip (e.g. 127.0.0.1)" />
      <input
        id="targetPort"
        placeholder="port (e.g. 9001)"
        style="width: 140px"
      />
      <button id="connectBtn">Connect</button>
    </div>
    <div class="status" id="connectStatus"></div>
    <pre id="log" aria-live="polite"></pre>

    <!-- Channel Management Section -->
    <h2>Channel Management</h2>

    <!-- All Channels List (fetched from tracker) -->
    <div class="row">
      <button id="fetchAllChannelsBtn">Fetch All Channels</button>
    </div>
    <ul id="allChannelList" style="list-style: none; padding: 0; margin: 8px 0">
      <!-- All channels from tracker will be listed here -->
    </ul>

    <!-- Joined Channels List -->
    <h3>Joined Channels</h3>
    <div class="row">
      <input id="channelName" placeholder="Channel name" />
      <button id="joinChannelBtn">Join Channel</button>
    </div>
    <ul
      id="joinedChannelList"
      style="list-style: none; padding: 0; margin: 8px 0"
    >
      <!-- Joined channels will be listed here -->
    </ul>

    <!-- Channel Message Display -->
    <div id="channelSection" style="display: none">
      <h3 id="selectedChannelTitle">Messages</h3>
      <div
        id="channelMessages"
        style="
          height: 180px;
          overflow-y: auto;
          background: #f6f8fa;
          border-radius: 6px;
          padding: 8px;
          margin-bottom: 8px;
        "
      >
        <!-- Messages for selected channel will appear here -->
      </div>
      <div class="row">
        <input
          id="channelMsgInput"
          placeholder="Type a message..."
          style="flex: 1"
        />
        <button id="sendChannelMsgBtn">Send</button>
      </div>
      <div class="status" id="sendChannelMsgStatus"></div>
    </div>

    <!-- Notification Badge (only for joined channels) -->
    <div
      id="channelNotification"
      style="margin: 8px 0; color: #e53e3e; font-weight: bold"
    ></div>

    <script>
      // ============================================================
      // FOR CHANNEL MANAGEMENT
      // ============================================================
      // Channel management state
      let allChannels = [];
      let joinedChannels = [];
      let channelMessages = {}; // {channel: [msg, ...]}
      // ============================================================
      // FOR CHANNEL MANAGEMENT
      // ============================================================
      // Sample all channels fetched from tracker
      // let allChannels = [
      //   "general",
      //   "random",
      //   "project",
      //   "help",
      //   "announcements",
      // ];
      // Sample joined channels
      // let joinedChannels = ["general", "random", "project"];
      // let channelMessages = {
      //   general: [
      //     { sender: "alice", text: "Welcome to general!", time: "09:01" },
      //     { sender: "bob", text: "Hi everyone!", time: "09:02" },
      //   ],
      //   random: [
      //     { sender: "carol", text: "Random thoughts...", time: "09:05" },
      //   ],
      //   project: [
      //     { sender: "alice", text: "Project kickoff at 10am.", time: "09:10" },
      //     { sender: "bob", text: "I'll be there!", time: "09:11" },
      //   ],
      // };
      let selectedChannel = null;
      let unreadChannels = new Set();

      // Render all channels list (from tracker)
      async function renderAllChannelList() {
        const res = await fetch("/get-all-channels");
        const text = await res.text();
        // route returns JSON string; attempt parse
        try {
          const result = JSON.parse(text);
          if (
            result.status === "success" &&
            Array.isArray(result["channels"])
          ) {
            allChannels = result["channels"];
          } else {
            allChannels = [];
          }
          console.log("Parsed all channels:", allChannels);
        } catch (e) {
          allChannels = [];
        }
        console.log("Fetched all channels:", allChannels);
        const ul = document.getElementById("allChannelList");
        ul.innerHTML = "";
        allChannels.forEach((ch) => {
          const li = document.createElement("li");
          li.style.cursor = "pointer";
          li.style.padding = "4px 0";
          li.textContent = ch;
          ul.appendChild(li);
        });
      }

      // Fetch all channels from tracker (simulate)
      document.getElementById("fetchAllChannelsBtn").onclick = async () => {
        // TODO: Replace with real API call to /get-all-channels
        // For demo, just use sample data
        renderAllChannelList();
      };

      // Render joined channels list
      function renderJoinedChannelList() {
        const ul = document.getElementById("joinedChannelList");
        ul.innerHTML = "";
        joinedChannels.forEach((ch) => {
          const li = document.createElement("li");
          li.style.cursor = "pointer";
          li.style.padding = "4px 0";
          li.textContent = ch;
          li.onclick = () => selectChannel(ch);
          if (ch === selectedChannel) li.style.fontWeight = "bold";
          if (unreadChannels.has(ch)) {
            li.innerHTML += ' <span style="color:#e53e3e;">‚óè</span>';
          }
          ul.appendChild(li);
        });
      }

      async function selectChannel(channel) {
        selectedChannel = channel;
        document.getElementById(
          "selectedChannelTitle"
        ).textContent = `Messages in "${channel}"`;
        document.getElementById("channelSection").style.display = "";
        unreadChannels.delete(channel);
        renderJoinedChannelList();

        // Fetch messages from peer API
        try {
          const res = await fetch("/get-channel-messages", {
            method: "GET",
            body: new URLSearchParams({ channel_name: channel }).toString(),
          });
          const text = await res.text();
          let result = {};
          try {
            result = JSON.parse(text);
          } catch (e) {
            result = {};
          }
          // result.messages should be an array of messages
          if (
            result.status === "success" &&
            result.messages &&
            Array.isArray(result.messages.messages)
          ) {
            channelMessages[channel] = result.messages.messages;
          } else {
            channelMessages[channel] = [];
          }
        } catch (e) {
          channelMessages[channel] = [];
        }
        renderChannelMessages();
      }

      function renderChannelMessages() {
        const div = document.getElementById("channelMessages");
        div.innerHTML = "";
        // Adapt to the return data from /get-channel-messages
        // The API returns: { status: "success", messages: { messages: [ ... ] } }
        // So channelMessages[selectedChannel] should be an array of message objects
        const msgs = channelMessages[selectedChannel] || [];
        if (!Array.isArray(msgs) || msgs.length === 0) {
          div.innerHTML = `<div style="color:#888;">No messages yet.</div>`;
          return;
        }
        msgs.forEach((msg) => {
          // Each msg: { sender, text, time }
          div.innerHTML += `<div>
      <span style="color:#3182ce;font-weight:bold;">${escapeHtml(
        msg.sender
      )}</span>
      <span style="color:#888;"> @ ${escapeHtml(msg.time)}</span>
      <div>${escapeHtml(msg.text)}</div>
    </div>`;
        });
        div.scrollTop = div.scrollHeight;
      }

      // Join channel
      document.getElementById("joinChannelBtn").onclick = async () => {
        const ch = document.getElementById("channelName").value.trim();
        if (!ch || joinedChannels.includes(ch)) return;
        const res = await fetch("/join-channel", {
          method: "POST",
          body: new URLSearchParams({ channel_name: ch }).toString(),
        });

        joinedChannels.push(ch);
        channelMessages[ch] = [];
        renderJoinedChannelList();
        selectChannel(ch);
      };

      // Send message to channel
      document.getElementById("sendChannelMsgBtn").onclick = async () => {
        const input = document.getElementById("channelMsgInput");
        const text = input.value.trim();
        const statusEl = document.getElementById("sendChannelMsgStatus");
        if (!selectedChannel || !text) {
          statusEl.textContent = "Select a channel and enter a message.";
          return;
        }
        try {
          const res = await fetch("/send-channel-message", {
            method: "POST",
            body: new URLSearchParams({
              channel_name: selectedChannel,
              message: text,
            }).toString(),
          });
          const resultText = await res.text();
          let result = {};
          try {
            result = JSON.parse(resultText);
          } catch (e) {
            result = {};
          }
          if (result.status === "success") {
            // Optionally, re-fetch messages to update the window
            await selectChannel(selectedChannel);
            statusEl.textContent = "Message sent.";
          } else {
            statusEl.textContent = "Error sending message.";
          }
          input.value = "";
          renderChannelMessages();
        } catch (e) {
          statusEl.textContent = "Error sending message.";
        }
      };

      // Poll for new messages and notifications (only for joined channels)
      async function pollChannelNotifications() {
        // Example: fetch new messages for all joined channels
        for (const ch of joinedChannels) {
          // console.log(ch)
          // if (ch !== selectedChannel) {
            try {
              const res = await fetch("/get-channel-messages", {
                method: "GET",
                body: new URLSearchParams({ channel_name: ch }).toString(),
              });
              const text = await res.text();
              let result = {};
              try {
                result = JSON.parse(text);
              } catch (e) {
                result = {};
              }
              if (
                result.status === "success" &&
                result.messages &&
                Array.isArray(result.messages.messages)
              ) {
                // If there are new messages, show notification
                if (
                  !channelMessages[ch] ||
                  result.messages.messages.length > channelMessages[ch].length
                ) {
                  channelMessages[ch] = result.messages.messages;
                  unreadChannels.add(ch);
                  renderJoinedChannelList();
                  document.getElementById(
                    "channelNotification"
                  ).textContent = `New message in channel "${ch}"`;
                  setTimeout(() => {
                    document.getElementById("channelNotification").textContent =
                      "";
                  }, 3000);
                }
              }
            } catch (e) {
              // Ignore errors
              console.error(e)
            }
          // }
        }
      }

      setInterval(pollChannelNotifications, 3000);
      setInterval(async () => {
        const res = await fetch("/get-joined-channels");
        const text = await res.text();
        // route returns JSON string; attempt parse
        try {
          const result = JSON.parse(text);
          if (
            result.status === "success" &&
            Array.isArray(result["channels"])
          ) {
            joinedChannels = result["channels"];
          } else {
            joinedChannels = [];
          }
          console.log("Parsed joined channels:", joinedChannels);
        } catch (e) {
          joinedChannels = [];
        }
        console.log("Fetched joined channels:", joinedChannels);
      }, 5000);
      // Initial render
      renderAllChannelList();
      renderJoinedChannelList();
      // =====================================================
      // OTHER PEER-TO-PEER FUNCTIONS
      // =====================================================
      const peersTableBody = document.querySelector("#peersTable tbody");
      const lastUpdated = document.getElementById("lastUpdated");
      const logEl = document.getElementById("log");

      async function fetchPeers() {
        try {
          const res = await fetch("/get-list");
          const text = await res.text();
          // route returns JSON string; attempt parse
          let peers = [];
          try {
            peers = JSON.parse(text);
          } catch (e) {
            peers = [];
          }
          renderPeers(peers);
          lastUpdated.textContent =
            "Updated: " + new Date().toLocaleTimeString();
        } catch (e) {
          renderPeers([]);
          lastUpdated.textContent = "Error fetching list";
          appendLog("Error fetching /get-list: " + e);
        }
      }

      function renderPeers(peers) {
        peersTableBody.innerHTML = "";
        if (!peers || peers.length === 0) {
          peersTableBody.innerHTML =
            '<tr><td colspan="4" style="text-align:center;color:#666">No peers yet</td></tr>';
          return;
        }
        peers.forEach((p) => {
          const tr = document.createElement("tr");
          tr.innerHTML = `<td>${escapeHtml(p.username || "")}</td>
                        <td>${escapeHtml(p.ip || "")}</td>
                        <td>${escapeHtml(p.port || "")}</td>
                        <td><button data-ip="${escapeAttr(
                          p.ip
                        )}" data-port="${escapeAttr(
            p.port
          )}">Connect</button></td>`;
          peersTableBody.appendChild(tr);
        });
        // attach connect handlers
        peersTableBody.querySelectorAll("button").forEach((btn) => {
          btn.addEventListener("click", () => {
            document.getElementById("targetIp").value = btn.dataset.ip;
            document.getElementById("targetPort").value = btn.dataset.port;
            startConnect();
          });
        });
      }

      // Register this peer by POSTing to /submit-info as form-encoded body (ip/port/username)
      document
        .getElementById("registerBtn")
        .addEventListener("click", async () => {
          const username = document.getElementById("username").value.trim();
          const statusEl = document.getElementById("registerStatus");
          if (!username) {
            statusEl.textContent = "username and port are required";
            return;
          }

          // Fetch information to peer
          const body = new URLSearchParams({
            username: username,
          }).toString();

          try {
            const res = await fetch("/submit-username", {
              method: "POST",
              body,
            });
            const text = await res.text();

            statusEl.textContent =
              "Registration submitted. Server response: " + text;
            appendLog(`Submitted submit-info for ${username}`);
            // refresh list after a short delay
            setTimeout(fetchPeers, 300);
          } catch (e) {
            statusEl.textContent = "Error submitting registration";
            appendLog("Error POST /submit-username: " + e);
          }
        });

      async function fetchConnectedPeers() {
        try {
          const res = await fetch("/get-connected-peers");
          const text = await res.text();
          let peers = [];
          try {
            peers = JSON.parse(text);
          } catch (e) {
            peers = [];
          }
          renderConnectedPeers(peers);
        } catch (e) {
          renderConnectedPeers([]);
          appendLog("Error fetching /get-connected-peers: " + e);
        }
      }

      function renderConnectedPeers(peers) {
        const tableBody = document.querySelector("#connectedPeersTable tbody");
        tableBody.innerHTML = "";
        if (!peers || peers.length === 0) {
          tableBody.innerHTML =
            '<tr><td colspan="3" style="text-align:center;color:#666">No connected peers yet</td></tr>';
          return;
        }
        peers.forEach((p) => {
          const tr = document.createElement("tr");
          tr.innerHTML = `<td>${escapeHtml(p.ip || "")}</td>
                        <td>${escapeHtml(p.port || "")}</td>
                        <td><button data-ip="${escapeAttr(
                          p.ip
                        )}" data-port="${escapeAttr(
            p.port
          )}">Disconnect</button></td>`;
          tableBody.appendChild(tr);
        });
        // attach disconnect handlers (not implemented on server yet)
        tableBody.querySelectorAll("button").forEach((btn) => {
          btn.addEventListener("click", () => {
            appendLog(
              `Disconnect not implemented. Would disconnect from ${btn.dataset.ip}:${btn.dataset.port}`
            );
          });
        });
      }

      // For sending messages
      document
        .getElementById("sendMsgBtn")
        .addEventListener("click", async () => {
          const ip = document.getElementById("msgPeerIp").value.trim();
          const port = document.getElementById("msgPeerPort").value.trim();
          const message = document.getElementById("msgContent").value.trim();
          const statusEl = document.getElementById("sendMsgStatus");
          if (!ip || !port || !message) {
            statusEl.textContent = "IP, port, and message are required";
            return;
          }
          const formdata = {
            ip: ip,
            port: port,
            message: message,
          };
          try {
            const body = new URLSearchParams(formdata).toString();
            const res = await fetch("/send-peer", {
              method: "POST",
              body,
            });
            const text = await res.text();
            statusEl.textContent = "Message sent. Server response: " + text;
            appendLog(`Sent message to ${ip}:${port} - "${message}"`);
          } catch (e) {
            statusEl.textContent = "Error sending message";
            appendLog("Error POST /send-message: " + e);
          }
        });

      // Refresh buttons
      document
        .getElementById("refreshBtn")
        .addEventListener("click", fetchPeers);

      document
        .getElementById("refreshConnectedBtn")
        .addEventListener("click", fetchConnectedPeers);
      // Auto-refresh toggle
      let autoRefresh = false;
      let autoId = null;
      document
        .getElementById("autoRefreshBtn")
        .addEventListener("click", () => {
          autoRefresh = !autoRefresh;
          const btn = document.getElementById("autoRefreshBtn");
          if (autoRefresh) {
            btn.textContent = "Stop auto-refresh";
            autoId = setInterval(fetchPeers, 5000);
          } else {
            btn.textContent = "Start auto-refresh";
            clearInterval(autoId);
          }
        });

      // Connect section
      document
        .getElementById("connectBtn")
        .addEventListener("click", startConnect);

      function startConnect() {
        const ip = document.getElementById("targetIp").value.trim();
        const port = document.getElementById("targetPort").value.trim();
        const formData = {
          ip: ip,
          port: port,
        };
        let encodedData = new URLSearchParams(formData).toString();
        fetch("/connect-peer", {
          method: "POST",
          body: encodedData,
        })
          .then((res) => res.text())
          .then((text) => {
            appendLog(`Server response from /connect-peer: ${text}`);
            fetchConnectedPeers();
            fetchPeers();
          })
          .catch((e) => {
            appendLog("Error POST /connect-peer: " + e);
          });
      }

      function appendLog(s) {
        logEl.textContent += `[${new Date().toLocaleTimeString()}] ${s}\n`;
        logEl.scrollTop = logEl.scrollHeight;
      }

      // small helpers
      function escapeHtml(s) {
        s = s === undefined || s === null ? "" : s.toString();
        return (s || "").replace(
          /[&<>"']/g,
          (c) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;",
            }[c])
        );
      }
      function escapeAttr(s) {
        s = s === undefined || s === null ? "" : s.toString();
        return (s || "").replace(/"/g, "&quot;");
      }

      function decodeHtml(s) {
        const txt = document.createElement("textarea");
        txt.innerHTML = s;
        return txt.value;
      }

      async function fetchReceivedMessages() {
        try {
          const res = await fetch("/get-received-messages");
          const text = await res.text();
          let msgs = [];
          try {
            msgs = JSON.parse(text);
          } catch (e) {
            msgs = [];
          }
          // Clear log and append each message
          msgs.forEach((msg) => {
            msg.message = decodeHtml(msg.message);
            msg.message = msg.message.replace(/\+/g, " ");
            appendLog(
              `Message from ${msg.sender_ip}:${msg.sender_port} - ${msg.message}`
            );
          });
        } catch (e) {
          // Optionally log error
        }
      }

      // Broadcast message
      document
        .getElementById("broadcastMsgBtn")
        .addEventListener("click", async () => {
          const message = document
            .getElementById("broadcastContent")
            .value.trim();
          const statusEl = document.getElementById("broadcastMsgStatus");
          if (!message) {
            statusEl.textContent = "Message is required";
            return;
          }
          const body = {
            message: message,
          };
          try {
            const res = await fetch("/broadcast-peer", {
              method: "POST",
              headers: { "Content-Type": "application/x-www-form-urlencoded" },
              body: JSON.stringify(body),
            });
            const text = await res.text();
            statusEl.textContent = "Broadcast sent. Server response: " + text;
            appendLog(`Broadcasted message: "${message}"`);
          } catch (e) {
            statusEl.textContent = "Error broadcasting message";
            appendLog("Error POST /broadcast-peer: " + e);
          }
        });

      // Poll every 3 seconds for new messages
      setInterval(fetchReceivedMessages, 3000);

      // initial load
      fetchPeers();
    </script>
  </body>
</html>
