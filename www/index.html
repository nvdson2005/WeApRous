<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Active Peers</title>
    <style>
      body {
        font-family: system-ui, Segoe UI, Roboto, Arial;
        max-width: 900px;
        margin: 24px auto;
        padding: 0 16px;
      }
      h1 {
        margin-bottom: 8px;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin: 12px 0;
      }
      th,
      td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
      }
      th {
        background: #f5f5f5;
      }
      .row {
        display: flex;
        gap: 8px;
        align-items: center;
        margin: 8px 0;
      }
      input,
      button {
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
      }
      button {
        cursor: pointer;
      }
      .status {
        margin-top: 8px;
        font-size: 0.95rem;
      }
      pre {
        background: #f6f8fa;
        padding: 8px;
        border-radius: 6px;
        overflow: auto;
      }
    </style>
  </head>
  <body>
    <h1>Active Peers</h1>

    <div class="row">
      <button id="refreshBtn">Refresh list</button>
      <button id="autoRefreshBtn">Start auto-refresh</button>
      <span id="lastUpdated" style="margin-left: 12px; color: #666"></span>
    </div>

    <table id="peersTable" aria-live="polite">
      <thead>
        <tr>
          <th>Username</th>
          <th>IP</th>
          <th>Port</th>
          <th>Action</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td colspan="4" style="text-align: center; color: #666">
            No peers yet
          </td>
        </tr>
      </tbody>
    </table>

    <!-- Connected Peers Section -->
    <h2>Connected Peers</h2>
    <div class="row">
      <button id="refreshConnectedBtn">Refresh connected</button>
    </div>
    <table id="connectedPeersTable" aria-live="polite">
      <thead>
        <tr>
          <th>IP</th>
          <th>Port</th>
          <th>Action</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td colspan="3" style="text-align: center; color: #666">
            No connected peers yet
          </td>
        </tr>
      </tbody>
    </table>

    <!-- Send Message Section -->
    <h2>Send Message to Peer</h2>
    <div class="row">
      <input id="msgPeerIp" placeholder="peer ip (e.g. 127.0.0.1)" />
      <input
        id="msgPeerPort"
        placeholder="peer port (e.g. 9001)"
        style="width: 140px"
      />
      <input id="msgContent" placeholder="message" style="width: 200px" />
      <button id="sendMsgBtn">Send Message</button>
    </div>
    <div class="status" id="sendMsgStatus"></div>

    <!-- Broadcast Message Section -->
    <h2>Broadcast Message to All Connected Peers</h2>
    <div class="row">
      <input
        id="broadcastContent"
        placeholder="broadcast message"
        style="width: 220px"
      />
      <button id="broadcastMsgBtn">Broadcast</button>
    </div>
    <div class="status" id="broadcastMsgStatus"></div>

    <h2>Register this peer</h2>
    <p>Provide a username for your peer.</p>
    <div class="row">
      <input id="username" placeholder="username" />
      <button id="registerBtn">Register</button>
    </div>
    <div class="status" id="registerStatus"></div>

    <h2>Connect to a peer</h2>
    <p>Enter target IP/port and attempt a WebSocket connection (ws://).</p>
    <div class="row">
      <input id="targetIp" placeholder="target ip (e.g. 127.0.0.1)" />
      <input
        id="targetPort"
        placeholder="port (e.g. 9001)"
        style="width: 140px"
      />
      <button id="connectBtn">Connect</button>
    </div>
    <div class="status" id="connectStatus"></div>
    <pre id="log" aria-live="polite"></pre>

    <script>
      const peersTableBody = document.querySelector("#peersTable tbody");
      const lastUpdated = document.getElementById("lastUpdated");
      const logEl = document.getElementById("log");

      async function fetchPeers() {
        try {
          const res = await fetch("/get-list");
          const text = await res.text();
          // route returns JSON string; attempt parse
          let peers = [];
          try {
            peers = JSON.parse(text);
          } catch (e) {
            peers = [];
          }
          renderPeers(peers);
          lastUpdated.textContent =
            "Updated: " + new Date().toLocaleTimeString();
        } catch (e) {
          renderPeers([]);
          lastUpdated.textContent = "Error fetching list";
          appendLog("Error fetching /get-list: " + e);
        }
      }

      function renderPeers(peers) {
        peersTableBody.innerHTML = "";
        if (!peers || peers.length === 0) {
          peersTableBody.innerHTML =
            '<tr><td colspan="4" style="text-align:center;color:#666">No peers yet</td></tr>';
          return;
        }
        peers.forEach((p) => {
          const tr = document.createElement("tr");
          tr.innerHTML = `<td>${escapeHtml(p.username || "")}</td>
                        <td>${escapeHtml(p.ip || "")}</td>
                        <td>${escapeHtml(p.port || "")}</td>
                        <td><button data-ip="${escapeAttr(
                          p.ip
                        )}" data-port="${escapeAttr(
            p.port
          )}">Connect</button></td>`;
          peersTableBody.appendChild(tr);
        });
        // attach connect handlers
        peersTableBody.querySelectorAll("button").forEach((btn) => {
          btn.addEventListener("click", () => {
            document.getElementById("targetIp").value = btn.dataset.ip;
            document.getElementById("targetPort").value = btn.dataset.port;
            startConnect();
          });
        });
      }

      // Register this peer by POSTing to /submit-info as form-encoded body (ip/port/username)
      document
        .getElementById("registerBtn")
        .addEventListener("click", async () => {
          const username = document.getElementById("username").value.trim();
          const statusEl = document.getElementById("registerStatus");
          if (!username) {
            statusEl.textContent = "username and port are required";
            return;
          }

          // Fetch information to peer
          const body = new URLSearchParams({
            username: username,
          }).toString();

          try {
            const res = await fetch("/submit-username", {
              method: "POST",
              body,
            });
            const text = await res.text();

            statusEl.textContent =
              "Registration submitted. Server response: " + text;
            appendLog(`Submitted submit-info for ${username}`);
            // refresh list after a short delay
            setTimeout(fetchPeers, 300);
          } catch (e) {
            statusEl.textContent = "Error submitting registration";
            appendLog("Error POST /submit-username: " + e);
          }
        });

      async function fetchConnectedPeers() {
        try {
          const res = await fetch("/get-connected-peers");
          const text = await res.text();
          let peers = [];
          try {
            peers = JSON.parse(text);
          } catch (e) {
            peers = [];
          }
          renderConnectedPeers(peers);
        } catch (e) {
          renderConnectedPeers([]);
          appendLog("Error fetching /get-connected-peers: " + e);
        }
      }

      function renderConnectedPeers(peers) {
        const tableBody = document.querySelector("#connectedPeersTable tbody");
        tableBody.innerHTML = "";
        if (!peers || peers.length === 0) {
          tableBody.innerHTML =
            '<tr><td colspan="3" style="text-align:center;color:#666">No connected peers yet</td></tr>';
          return;
        }
        peers.forEach((p) => {
          const tr = document.createElement("tr");
          tr.innerHTML = `<td>${escapeHtml(p.ip || "")}</td>
                        <td>${escapeHtml(p.port || "")}</td>
                        <td><button data-ip="${escapeAttr(
                          p.ip
                        )}" data-port="${escapeAttr(
            p.port
          )}">Disconnect</button></td>`;
          tableBody.appendChild(tr);
        });
        // attach disconnect handlers (not implemented on server yet)
        tableBody.querySelectorAll("button").forEach((btn) => {
          btn.addEventListener("click", () => {
            appendLog(
              `Disconnect not implemented. Would disconnect from ${btn.dataset.ip}:${btn.dataset.port}`
            );
          });
        });
      }

      // For sending messages
      document
        .getElementById("sendMsgBtn")
        .addEventListener("click", async () => {
          const ip = document.getElementById("msgPeerIp").value.trim();
          const port = document.getElementById("msgPeerPort").value.trim();
          const message = document.getElementById("msgContent").value.trim();
          const statusEl = document.getElementById("sendMsgStatus");
          if (!ip || !port || !message) {
            statusEl.textContent = "IP, port, and message are required";
            return;
          }
          const formdata = {
            ip: ip,
            port: port,
            message: message,
          };
          try {
            const body = new URLSearchParams(formdata).toString();
            const res = await fetch("/send-peer", {
              method: "POST",
              body,
            });
            const text = await res.text();
            statusEl.textContent = "Message sent. Server response: " + text;
            appendLog(`Sent message to ${ip}:${port} - "${message}"`);
          } catch (e) {
            statusEl.textContent = "Error sending message";
            appendLog("Error POST /send-message: " + e);
          }
        });

      // Refresh buttons
      document
        .getElementById("refreshBtn")
        .addEventListener("click", fetchPeers);

      document
        .getElementById("refreshConnectedBtn")
        .addEventListener("click", fetchConnectedPeers);
      // Auto-refresh toggle
      let autoRefresh = false;
      let autoId = null;
      document
        .getElementById("autoRefreshBtn")
        .addEventListener("click", () => {
          autoRefresh = !autoRefresh;
          const btn = document.getElementById("autoRefreshBtn");
          if (autoRefresh) {
            btn.textContent = "Stop auto-refresh";
            autoId = setInterval(fetchPeers, 5000);
          } else {
            btn.textContent = "Start auto-refresh";
            clearInterval(autoId);
          }
        });

      // Connect section
      document
        .getElementById("connectBtn")
        .addEventListener("click", startConnect);

      function startConnect() {
        const ip = document.getElementById("targetIp").value.trim();
        const port = document.getElementById("targetPort").value.trim();
        const formData = {
          ip: ip,
          port: port,
        };
        let encodedData = new URLSearchParams(formData).toString();
        fetch("/connect-peer", {
          method: "POST",
          body: encodedData,
        })
          .then((res) => res.text())
          .then((text) => {
            appendLog(`Server response from /connect-peer: ${text}`);
            fetchConnectedPeers();
            fetchPeers();
          })
          .catch((e) => {
            appendLog("Error POST /connect-peer: " + e);
          });
      }

      function appendLog(s) {
        logEl.textContent += `[${new Date().toLocaleTimeString()}] ${s}\n`;
        logEl.scrollTop = logEl.scrollHeight;
      }

      // small helpers
      function escapeHtml(s) {
        s = s === undefined || s === null ? "" : s.toString();
        return (s || "").replace(
          /[&<>"']/g,
          (c) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;",
            }[c])
        );
      }
      function escapeAttr(s) {
        s = s === undefined || s === null ? "" : s.toString();
        return (s || "").replace(/"/g, "&quot;");
      }

      function decodeHtml(s) {
        const txt = document.createElement("textarea");
        txt.innerHTML = s;
        return txt.value;
      }
      async function fetchReceivedMessages() {
        try {
          const res = await fetch("/get-received-messages");
          const text = await res.text();
          let msgs = [];
          try {
            msgs = JSON.parse(text);
          } catch (e) {
            msgs = [];
          }
          // Clear log and append each message
          msgs.forEach((msg) => {
            msg.message = decodeHtml(msg.message);
            msg.message = msg.message.replace(/\+/g, " ");
            appendLog(
              `Message from ${msg.sender_ip}:${msg.sender_port} - ${msg.message}`
            );
          });
        } catch (e) {
          // Optionally log error
        }
      }

      // Broadcast message
      document
        .getElementById("broadcastMsgBtn")
        .addEventListener("click", async () => {
          const message = document
            .getElementById("broadcastContent")
            .value.trim();
          const statusEl = document.getElementById("broadcastMsgStatus");
          if (!message) {
            statusEl.textContent = "Message is required";
            return;
          }
          const body = {
            message: message,
          };
          try {
            const res = await fetch("/broadcast-peer", {
              method: "POST",
              headers: { "Content-Type": "application/x-www-form-urlencoded" },
              body: JSON.stringify(body),
            });
            const text = await res.text();
            statusEl.textContent = "Broadcast sent. Server response: " + text;
            appendLog(`Broadcasted message: "${message}"`);
          } catch (e) {
            statusEl.textContent = "Error broadcasting message";
            appendLog("Error POST /broadcast-peer: " + e);
          }
        });

      // Poll every 3 seconds for new messages
      setInterval(fetchReceivedMessages, 3000);

      // initial load
      fetchPeers();
    </script>
  </body>
</html>
