<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Active Peers</title>
    <style>
      body {
        font-family: system-ui, Segoe UI, Roboto, Arial;
        max-width: 900px;
        margin: 24px auto;
        padding: 0 16px;
      }
      h1 {
        margin-bottom: 8px;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin: 12px 0;
      }
      th,
      td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
      }
      th {
        background: #f5f5f5;
      }
      .row {
        display: flex;
        gap: 8px;
        align-items: center;
        margin: 8px 0;
      }
      input,
      button {
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
      }
      button {
        cursor: pointer;
      }
      .status {
        margin-top: 8px;
        font-size: 0.95rem;
      }
      pre {
        background: #f6f8fa;
        padding: 8px;
        border-radius: 6px;
        overflow: auto;
      }
    </style>
  </head>
  <body>
    <h1>Active Peers</h1>

    <div class="row">
      <button id="refreshBtn">Refresh list</button>
      <button id="autoRefreshBtn">Start auto-refresh</button>
      <span id="lastUpdated" style="margin-left: 12px; color: #666"></span>
    </div>

    <table id="peersTable" aria-live="polite">
      <thead>
        <tr>
          <th>Username</th>
          <th>IP</th>
          <th>Port</th>
          <th>Action</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td colspan="4" style="text-align: center; color: #666">
            No peers yet
          </td>
        </tr>
      </tbody>
    </table>

    <!-- Connected Peers Section -->
    <h2>Connected Peers</h2>
    <div class="row">
      <button id="refreshConnectedBtn">Refresh connected</button>
    </div>
    <table id="connectedPeersTable" aria-live="polite">
      <thead>
        <tr>
          <th>IP</th>
          <th>Port</th>
          <th>Action</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td colspan="3" style="text-align: center; color: #666">
            No connected peers yet
          </td>
        </tr>
      </tbody>
    </table>

    <!-- Send Message Section -->
    <h2>Send Message to Peer</h2>
    <div class="row">
      <input id="msgPeerIp" placeholder="peer ip (e.g. 127.0.0.1)" />
      <input
        id="msgPeerPort"
        placeholder="peer port (e.g. 9001)"
        style="width: 140px"
      />
      <input id="msgContent" placeholder="message" style="width: 200px" />
      <button id="sendMsgBtn">Send Message</button>
    </div>
    <div class="status" id="sendMsgStatus"></div>

    <h2>Register this peer</h2>
    <p>
      Provide a username and the port your client will accept WebSocket
      connections on.
    </p>
    <div class="row">
      <input id="username" placeholder="username" />
      <input
        id="localPort"
        placeholder="port (e.g. 9001)"
        style="width: 140px"
      />
      <button id="registerBtn">Register (POST /submit-info)</button>
    </div>
    <div class="status" id="registerStatus"></div>

    <h2>Connect to a peer</h2>
    <p>Enter target IP/port and attempt a WebSocket connection (ws://).</p>
    <div class="row">
      <input id="targetIp" placeholder="target ip (e.g. 127.0.0.1)" />
      <input
        id="targetPort"
        placeholder="port (e.g. 9001)"
        style="width: 140px"
      />
      <button id="connectBtn">Connect</button>
    </div>
    <div class="status" id="connectStatus"></div>
    <pre id="log" aria-live="polite"></pre>

    <script>
      const peersTableBody = document.querySelector("#peersTable tbody");
      const lastUpdated = document.getElementById("lastUpdated");
      const logEl = document.getElementById("log");

      async function fetchPeers() {
        try {
          const res = await fetch("/get-list");
          const text = await res.text();
          // route returns JSON string; attempt parse
          let peers = [];
          try {
            peers = JSON.parse(text);
          } catch (e) {
            peers = [];
          }
          renderPeers(peers);
          lastUpdated.textContent =
            "Updated: " + new Date().toLocaleTimeString();
        } catch (e) {
          renderPeers([]);
          lastUpdated.textContent = "Error fetching list";
          appendLog("Error fetching /get-list: " + e);
        }
      }

      function renderPeers(peers) {
        peersTableBody.innerHTML = "";
        if (!peers || peers.length === 0) {
          peersTableBody.innerHTML =
            '<tr><td colspan="4" style="text-align:center;color:#666">No peers yet</td></tr>';
          return;
        }
        peers.forEach((p) => {
          const tr = document.createElement("tr");
          tr.innerHTML = `<td>${escapeHtml(p.username || "")}</td>
                        <td>${escapeHtml(p.ip || "")}</td>
                        <td>${escapeHtml(p.port || "")}</td>
                        <td><button data-ip="${escapeAttr(
                          p.ip
                        )}" data-port="${escapeAttr(
            p.port
          )}">Connect</button></td>`;
          peersTableBody.appendChild(tr);
        });
        // attach connect handlers
        peersTableBody.querySelectorAll("button").forEach((btn) => {
          btn.addEventListener("click", () => {
            document.getElementById("targetIp").value = btn.dataset.ip;
            document.getElementById("targetPort").value = btn.dataset.port;
            startConnect();
          });
        });
      }

      // Register this peer by POSTing to /submit-info as form-encoded body (ip/port/username)
      document
        .getElementById("registerBtn")
        .addEventListener("click", async () => {
          const username = document.getElementById("username").value.trim();
          const port = document.getElementById("localPort").value.trim();
          const statusEl = document.getElementById("registerStatus");
          if (!username || !port) {
            statusEl.textContent = "username and port are required";
            return;
          }

          // use current page hostname as IP
          const ip = location.hostname;
          const body = `ip=${encodeURIComponent(ip)}&port=${encodeURIComponent(
            port
          )}&username=${encodeURIComponent(username)}`;

          try {
            const res = await fetch("/submit-info", {
              method: "POST",
              headers: { "Content-Type": "application/x-www-form-urlencoded" },
              body,
            });
            statusEl.textContent =
              "Submitted registration (server may not return content).";
            appendLog(`Submitted submit-info for ${username}@${ip}:${port}`);
            // refresh list after a short delay
            setTimeout(fetchPeers, 300);
          } catch (e) {
            statusEl.textContent = "Error submitting registration";
            appendLog("Error POST /submit-info: " + e);
          }
        });

      async function fetchConnectedPeers() {
        try {
          const res = await fetch("/get-connected-peers");
          const text = await res.text();
          let peers = [];
          try {
            peers = JSON.parse(text);
          } catch (e) {
            peers = [];
          }
          renderConnectedPeers(peers);
        } catch (e) {
          renderConnectedPeers([]);
          appendLog("Error fetching /get-connected-peers: " + e);
        }
      }

      function renderConnectedPeers(peers) {
        const tableBody = document.querySelector(
          "#connectedPeersTable tbody"
        );
        tableBody.innerHTML = "";
        if (!peers || peers.length === 0) {
          tableBody.innerHTML =
            '<tr><td colspan="3" style="text-align:center;color:#666">No connected peers yet</td></tr>';
          return;
        }
        peers.forEach((p) => {
          const tr = document.createElement("tr");
          tr.innerHTML = `<td>${escapeHtml(p.ip || "")}</td>
                        <td>${escapeHtml(p.port || "")}</td>
                        <td><button data-ip="${escapeAttr(
                          p.ip
                        )}" data-port="${escapeAttr(
            p.port
          )}">Disconnect</button></td>`;
          tableBody.appendChild(tr);
        });
        // attach disconnect handlers (not implemented on server yet)
        tableBody.querySelectorAll("button").forEach((btn) => {
          btn.addEventListener("click", () => {
            appendLog(
              `Disconnect not implemented. Would disconnect from ${btn.dataset.ip}:${btn.dataset.port}`
            );
          });
        });
      }

      document
        .getElementById("refreshBtn")
        .addEventListener("click", fetchPeers);
      
      document
        .getElementById("refreshConnectedBtn")
        .addEventListener("click", fetchConnectedPeers);
      // Auto-refresh toggle
      let autoRefresh = false;
      let autoId = null;
      document
        .getElementById("autoRefreshBtn")
        .addEventListener("click", () => {
          autoRefresh = !autoRefresh;
          const btn = document.getElementById("autoRefreshBtn");
          if (autoRefresh) {
            btn.textContent = "Stop auto-refresh";
            autoId = setInterval(fetchPeers, 5000);
          } else {
            btn.textContent = "Start auto-refresh";
            clearInterval(autoId);
          }
        });

      // Connect section
      document
        .getElementById("connectBtn")
        .addEventListener("click", startConnect);

      function startConnect() {
        const ip = document.getElementById("targetIp").value.trim();
        const port = document.getElementById("targetPort").value.trim();
        const formData = {
          ip: ip,
          port: port,
        };
        let encodedData = new URLSearchParams(formData).toString();
        fetch("/connect-peer", {
          method: "POST",
          body: encodedData,
        })
          .then((res) => res.text())
          .then((text) => {
            appendLog(`Server response from /connect-peer: ${text}`);
          })
          .catch((e) => {
            appendLog("Error POST /connect-peer: " + e);
          });
        // const status = document.getElementById('connectStatus');
        // if(!ip || !port){ status.textContent = 'target ip and port required'; return; }
        // status.textContent = `Connecting to ws://${ip}:${port} ...`;
        // appendLog(`Attempting ws://${ip}:${port}`);

        // try{
        //   const ws = new WebSocket(`ws://${ip}:${port}`);
        //   ws.onopen = ()=> {
        //     status.textContent = 'WebSocket connected';
        //     appendLog('WebSocket open');
        //     // send a simple hello
        //     ws.send('hello from peers.html');
        //   };
        //   ws.onmessage = (ev)=> {
        //     appendLog('Message: ' + ev.data);
        //   };
        //   ws.onerror = (ev)=> {
        //     status.textContent = 'WebSocket error';
        //     appendLog('WebSocket error: ' + JSON.stringify(ev));
        //   };
        //   ws.onclose = ()=> {
        //     status.textContent = 'WebSocket closed';
        //     appendLog('WebSocket closed');
        //   };
        // }catch(e){
        //   status.textContent = 'Failed to create WebSocket: ' + e;
        //   appendLog('WebSocket exception: ' + e);
        // }
      }

      function appendLog(s) {
        logEl.textContent += `[${new Date().toLocaleTimeString()}] ${s}\n`;
        logEl.scrollTop = logEl.scrollHeight;
      }

      // small helpers
      function escapeHtml(s) {
        s = (s === undefined || s === null) ? "" : s.toString();
        return (s || "").replace(
          /[&<>"']/g,
          (c) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;",
            }[c])
        );
      }
      function escapeAttr(s) {
        s = (s === undefined || s === null) ? "" : s.toString();
        return (s || "").replace(/"/g, "&quot;");
      }

      async function fetchReceivedMessages() {
        try {
          const res = await fetch("/get-received-messages");
          const text = await res.text();
          let msgs = [];
          try {
            msgs = JSON.parse(text);
          } catch (e) {
            msgs = [];
          }
          // Clear log and append each message
          msgs.forEach((msg) => {
            appendLog(
              `Message from ${msg.sender_ip}:${msg.sender_port} - ${msg.message}`
            );
          });
        } catch (e) {
          // Optionally log error
        }
      }

      // Poll every 3 seconds for new messages
      setInterval(fetchReceivedMessages, 3000);

      // initial load
      fetchPeers();
    </script>
  </body>
</html>
